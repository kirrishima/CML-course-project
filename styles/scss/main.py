l = """
// Инициализация указателей p1 и p2 для массивов nums1 и nums2
p1 := 0
p2 := 0

// Функция getMin получает минимальный элемент из текущих позиций указателей p1 и p2
function getMin(nums1, m, nums2, n)
    // Если оба указателя в пределах массивов nums1 и nums2
    if p1 < m and p2 < n then
        // Возвращаем меньший элемент из nums1[p1] и nums2[p2], после чего сдвигаем соответствующий указатель
        return min(nums1[p1], nums2[p2]) // возвращаем и увеличиваем p1 или p2
    // Если указатель p1 находится в пределах nums1
    else if p1 < m then
        // Возвращаем элемент из nums1[p1], после чего сдвигаем указатель p1
        return nums1[p1++] // возвращаем и увеличиваем p1
    // Если указатель p2 находится в пределах nums2
    else if p2 < n then
        // Возвращаем элемент из nums2[p2], после чего сдвигаем указатель p2
        return nums2[p2++] // возвращаем и увеличиваем p2
    // Если оба указателя вышли за пределы своих массивов, возвращаем -1
    return -1

// Функция findMedianSortedArrays находит медиану двух упорядоченных массивов
function findMedianSortedArrays(nums1, m, nums2, n)
    // Если сумма длин массивов четная
    if (m + n) % 2 == 0 then
        // Повторяем процесс нахождения минимума m + n / 2 - 1 раз
        repeat (m + n) / 2 - 1 times
            _ := getMin(nums1, m, nums2, n)
        // Возвращаем среднее арифметическое двух элементов
        return (getMin(nums1, m, nums2, n) + getMin(nums1, m, nums2, n)) / 2
    // Если сумма длин массивов нечетная
    else
        // Повторяем процесс нахождения минимума m + n / 2 раз
        repeat (m + n) / 2 times
            _ := getMin(nums1, m, nums2, n)
        // Возвращаем значение медианы
        return getMin(nums1, m, nums2, n)

    // Если не удалось найти медиану, возвращаем -1
    return -1
"""
l = l.replace("else", "ИНАЧЕ").replace("if", "ЕСЛИ").replace("return", "ВЕРНУТЬ").replace("while", "ПОКА")
print(l)